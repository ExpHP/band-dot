#!/usr/bin/env python3

from collections import defaultdict
from functools import reduce
import numpy as np
import json

try:
    from clint.textui import colored
except ImportError:
    class DummyColored:
        def __getattr__(self, attr):
            return lambda s: s
    colored = DummyColored()

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Human-readible dot products between two eigenvector files')

    parser.add_argument('AFILE', type=str)
    parser.add_argument('BFILE', type=str)
    parser.add_argument('-t', '--threshold', type=float, default=1e-3,
        help='display threshold. (the dot products form a fairly'
        ' sparse matrix so most elements are not worth showing)')
    parser.add_argument('-0', action='store_true', dest='zero', help='use zero-based indexing')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-a', action='store_true', help='sort by a index (default)')
    group.add_argument('-b', action='store_true', help='sort by b index')

    parser.add_argument('-T', action='store_true', help='transpose array') # FIXME remove
    parser.add_argument('-s', '--subspaces', action='store_true', help='subspaces mode')
    parser.add_argument('--find-permutation', action='store_true',
        help='print permutation of the BFILE bands which most closely'
        ' block diagonalizes the dot products.  (given as 1-based indices'
        ' of the original bands)')
    args = parser.parse_args()

    if not (args.a or args.b):
        args.a = True

    A = read_eigenvectors(args.AFILE, args.T)
    B = read_eigenvectors(args.BFILE, args.T)

    if len(A[0]) != len(B[0]):
        parser.error('{} and {} have incompatible dimension'.format(args.AFILE, args.BFILE))

    fmtlen = len(str(len(A)))
    fmt = "{{:{}}} {{:{}}}   {{:<22}}  {{:8}}Â°".format(fmtlen, fmtlen)

    def getdot(a, b):
        dot = np.vdot(a, b)
        if np.absolute(dot)**2 < args.threshold:
            return 0
        return dot

    mode = 'normal'
    if args.subspaces: mode = 'subspaces'
    if args.find_permutation: mode = 'permutation'

    idx_display_offset = 0 if args.zero else 1

    def sparse_dots():
        result = defaultdict(dict)
        for ai,a in enumerate(np.array(A)):
            for bi,b in enumerate(np.array(B)):
                dot = getdot(a, b)
                if dot:
                    result[ai][bi] = abs(dot)
        return result
    sparse_dots = sparse_dots()

    if mode == 'normal':
        def showitem(ai, bi):
            dot = sparse_dots[ai].get(bi, 0)
            if dot:
                print(fmt.format(
                    ai + idx_display_offset,
                    bi + idx_display_offset,
                    abs(dot),
                    int(round(np.degrees(np.angle(dot))))),
                )

        if args.a:
            for ai in range(len(A)):
                for bi in range(len(B)):
                    showitem(ai, bi)
        elif args.b:
            for bi in range(len(B)):
                for ai in range(len(A)):
                    showitem(ai, bi)
        else: assert False, 'complete switch'

    elif mode == 'subspaces':

        pairs = subspaces(sparse_dots)
        if args.b:
            pairs = sorted(pairs, key=lambda pair: min(pair[1]))

        for aset, bset in pairs:
            fmt_nocolor = lambda s: lambda *a, **k: s.format(*a, **k)
            header_fmt = " ".join(["{:5}"] + ["{:^5}"] * len(bset))
            body_fmts = [fmt_nocolor("{:5}")] + [fmt_color_by_value("{:<0.3f}")] * len(bset)
            print(header_fmt.format(" ", *[ib + idx_display_offset for ib in bset]))
            for ia in aset:
                to_print = [ia + idx_display_offset] + [abs(sparse_dots[ia].get(ib, 0))**2 for ib in bset]
                print(*(f(x) for (f, x) in zip(body_fmts, to_print)))
            print()

    elif mode == 'permutation':
        perm = find_permutation(sparse_dots)
        print([x + idx_display_offset for x in perm])

    else: assert False, "complete switch"

def read_eigenvectors(path, transpose):
    lower = path.lower()
    if lower.endswith('.npy'):
        data = np.load(path)
    elif lower.endswith('.json'):
        data = np.array(json.load(path))
        # Allow an extra axis for complex numbers
        if data.ndim == 3:
            if data.shape[2] != 2:
                die('expected JSON third axis to be real/imag')
            data = data[:, :, 0] + 1j * data[:, :, 1]
    else:
        die(f'cannot determine format of {path}; try using a .npy or .json extension')

    if transpose:
        data = data.T
    if data.ndim != 2:
        die('expected 2D npy or 2D/3D json')
    return data

def fmt_color_by_value(s):
    return lambda x: color_by_value(x)(s.format(x))

def color_by_value(x):
    x = abs(float(x))
    if x < 0.30: return colored.blue
    if x < 0.60: return colored.cyan
    if x < 0.80: return colored.yellow
    return colored.white

# returns [(aset, bset)] where aset and bset are a set of indices from
#    each file that have nonzero dot products
def subspaces(sparse_dots):
    sparse_sets = {k:set(v) for (k,v) in sparse_dots.items()}
    unique_b_sets = group_into_non_overlapping_sets(sparse_sets.values())

    @thru(sorted, key=lambda pair: min(pair[0]))
    def pairs():
        for bbs in unique_b_sets:
            aas = [a for a in sparse_sets if sparse_sets[a] & bbs]
            yield (sorted(aas), sorted(bbs))

    return pairs()

def group_into_non_overlapping_sets(sets):
    sets = [frozenset(s) for s in sets]

    @thru(set)
    def step(sets):
        for s in sets:
            yield reduce(frozenset.union, [x for x in sets if x & s], frozenset())

    return frozenset(fixpoint(sets, step))

# returns [abset] where abset is a set of contiguous indices representing
#  a block diagonal block in the dot product matrix
#
# Compared to 'subspaces', this is less informative and produces larger subspaces.  It exists as a
# crutch for code that is not yet equipped to deal with the added complexity of non-contiguous subspaces.
def block_slices(sparse_abs):
    pairs = subspaces(sparse_abs)
    sets = [  frozenset(range(min(aas), max(aas)+1))
            | frozenset(range(min(bbs), max(bbs)+1))
            for (aas, bbs) in pairs]
    sets = group_into_non_overlapping_sets(sets)
    sets = sorted(sets, key=min)
    return [slice(min(x), max(x)+1) for x in sets]

def thru(outer, *a1, **k1):
    return lambda f: lambda *a2, **k2: outer(f(*a2, **k2), *a1, **k1)

def group_keys_by_matching_value(d):
    inv = defaultdict(set)
    for (k, v) in d.items():
        inv[v].add(k)
    return [(ks, v) for v in inv]

def find_permutation(sparse_dots):
    import scipy.sparse as sparse

    n = len(sparse_dots)
    sparse_abs = {s: {t: abs(v) for (t, v) in vs.items()} for (s, vs) in sparse_dots.items()}

    def coo_matrix_from_triples(triples):
        i, j, x = zip(*ijvpairs())
        return sparse.coo_matrix((list(x), (list(i), list(j))))

    def ijvpairs():
        for i in range(n):
            for j in range(n):
                v = sparse_abs[i].get(j, 0)
                if v:
                    yield (i, j, v)
    mat = coo_matrix_from_triples(ijvpairs()).tocsc()

    perm = np.arange(len(sparse_abs))

    # permute to optimize an objective function within each block subspace
    for slc in block_slices(sparse_abs):
        block = mat[slc, slc]
        # surprise surprise scipy we actually want elementwise multiplication
        block = np.array(block.todense().tolist())

        size = block.shape[0]
        weights = (np.arange(size)[:, None] - np.arange(size)[None, :])**2

        objective = lambda block: (block * weights).sum()

        # a function that tries swapping each pair of indices once, greedily accepting any
        # changes that reduce the objective function
        def step(data):
            block, perm = data
            block, perm = block.arr, perm.arr
            bestBlock, bestPerm, bestValue = block, perm, objective(block)

            for i in range(size):
                for j in range(size):
                    if i == j: continue
                    block, perm = bestBlock.copy(), bestPerm.copy()
                    block[:,[i,j]] = block[:,[j,i]]
                    perm[[i,j]] = perm[[j,i]]

                    if (bestValue is None) or objective(block) < bestValue:
                        bestBlock = block.copy()
                        bestValue = objective(block)
                        bestPerm  = perm.copy()

            return CompareAsBool(bestBlock), CompareAsBool(bestPerm)

        # now we just have to repeatedly apply that function until it stops producing any changes
        _, out = fixpoint((CompareAsBool(block), CompareAsBool(perm[slc])), step)
        perm[slc] = out.arr

    return perm

# ffs numpy
class CompareAsBool:
    def __init__(self, arr): self.arr = arr
    def __eq__(self, other): return (self.arr == other.arr).all()

def fixpoint(x, f):
    while True:
        next = f(x)
        if next == x:
            return x
        x = next

# ------------------------------------------------------

def warn(*args, **kw):
    print(f'{PROG}:', *args, file=sys.stderr, **kw)

def die(*args, code=1):
    warn('Fatal:', *args)
    sys.exit(code)

# ------------------------------------------------------

if __name__ == '__main__':
    main()
